# 5. 다형성(polymorphism)

## 5.1 다형성이란?

`다형성`이란, 여러가지 형태를 가질 수 있는 능력을 말한다. 자바에서는 **조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록**하여 다형성을 구현하였다.

```jsx
CaptionTv c = new CaptionTv();
Tv t = new CaptionTv(); //조상 타입의 참조변수로 자손인스턴스를 참조
```

위의 코드에서 c, t 둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다. 참조변수 t로는 CaptionTv 인스턴스의 모든 멤버를 사용할 수 없다.

반대로, 아래 코드와 같이 자손타입의 참조변수로 조상 타입의 인스턴스를 참조하는 것은 불가능하다.

```jsx
CaptionTv c = new Tv(); //컴파일 에러
```

왜냐하면 실제 인스턴스인 Tv의 멤버 개수보다 참조변수 c가 사용할 수 있는 멤버개수가 더 많기 때문에 이를 허용하지 않기 때문이다. 자손 타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 존재하지 않는 멤버를 사용하고자 할 가능성이 있으므로 허용하지 않는 것이다.

따라서 **참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다.**

> 🫐 요약
조상타입의 참조 변수로 자손타입의 인스턴스를 참조할 수 있다. 
자손타입의 참조 변수로 조상타입의 인스턴스를 참조할 수 없다.
> 

## 5.2 참조변수의 형변환

기본형 변수처럼 참조변수도 형변환이 가능하다. 단 서로 상속관계에 있는 클래스 사이에서만 가능하다.

**자손타입에서 조상타입으로** 형변환하는 것을 `up-casting` , **조상타입에서 자손타입으로** 형변환하는 것을 `down-casting`이라 한다. 이때 up-casting의 경우 형변환을 생략할 수 있지만 down-casting은 그렇지 않다.

**형변환은 참조변수의 타입을 변환하는 것이지, 인스터스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다. 단지 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것이다.**

5.1에서 예로 든 `Tv t = new CaptionTv();`의 경우도, `Tv t = (Tv) new CaptionTv();`의 생략된 형태이다.

서로 상속관계에 있는 타입 간의 형변환은 양방향으로 자유롭게 수행될 수 있으나, **참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.** 따라서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요하다. (instanceof)

```jsx
class CastingTest1 {
	public static void main(String[] args[]) {
		Car car = null;
		FireEngine fe = new FireEngine();
		FireEngine fe2 = new FireEngine();

		car = fe; //업캐스팅. car = (Car)fe;에서 형변환이 생략된 형태
		fe2 = (FireEngine)car; //다운캐스팅. 자손타입 <- 조상타입
	}
}

class CastingTest2 {
	public static void main(String args[]) {
		Car car = new Car();
		Car car2 = null;
		FireEngine fe = null;

		fe = (FireEngine)car; //컴파일은 OK. 실행 시 에러가 발생
		car2 = fe;
	}
}
```

위의 코드에서 CastingTest2의 경우 컴파일은 성공하지만 실행 시 에러(`ClassCastException`)가 발생한다. 형변환에 오류가 있기 때문인데, 참조변수 car가 참조하고 있는 인스턴스가 Car타입의 인스턴스라는 점이 문제이다. 왜냐하면 **조상타입의 인스턴스를 자손타입의 참조변수로 참조하는 것이 허용되지 않기 때문**이다.

따라서 위의 예제에서 `Car car = new Car();` 를 `Car car = new FireEngine();` 과 같이 변경하면 문제가 해결된다. 

컴파일 시 문제가 발생하지 않고 실행 시 문제가 발생하는 이유는 컴파일 시에는 참조변수 간의 타입만 체크하기 때문이다.

## 5.3 instanceof 연산자

`instanceof`연산자는 참조변수가 **참조하고 있는 인스턴스의 실제 타입을 알아보기 위해** 사용된다. 주로 조건문에 사용되며 `(참조변수) instanceof (타입(클래스명))`의 형태로 사용된다. 연산결과가 true인 경우 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 뜻한다. 위에서 설명했듯, 참조변수의 타입과 인스턴스의 타입이 항상 일치하지는 않는다. 조상타입의 참조변수로는 실제 인스턴스의 멤버들을 모두 사용할 수 없기 때문에, 실제 인스턴스와 같은 타입의 참조변수로 형변환을 해야만 인스턴스의 모든 멤버들을 사용할 수 있다.

또한 실제 인스턴스와 같은 타입의 instanceof 연산 이외에 조상타입의 instanceof 연산에서 true를 결과로 얻으며, instanceof 연산의 결과가 true라는 것은 검사한 타입으로의 형변환을 해도 문제가 없다는 뜻이다.

## 5.4 참조변수와 인스턴스의 연결

조상 클래스에 선언된 멤버변수와 같은 이름의 인스턴스 변수를 자손 클래스에 중복으로 정의했을 때, 조상타입의 참조변수로 자손 인스턴스를 참조하는 경우와 자손타입의 참조변수로 자손인스턴스를 참조하는 경우는 서로 다른결과를 얻는다.

- 메서드의 경우
    
    조상 클래스의 메서드를 자손 클래스에서 오버라이딩한 경우에도 참조변수의 타입에 관계없이 **항상 실제 인스턴스의 메서드(오버라이딩된 메서드)가 호출된다.**
    
- 멤버변수의 경우
    
    **참조변수의 타입에 따라 달라진다.**
    
    멤버 변수가 조상클래스와 자손클래스에 중복으로 정의된 경우, 조상타입의 참조변수를 사용했을 때는 조상클래스에 선언된 멤버변수가 사용된다.
    
    자손 타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다.
    

```jsx
class BindingTest {
	public static void main(String[] args) {
		Parent p = new Child(); //참조변수 : Parent / 실제 인스턴스 : Child
		Child c = new Child(); //참조변수 : Child / 실제 인스턴스 : Child

		System.out.println("p.x = " + p.x); //중복시 참조변수 타입에 따라 달라짐 -> 결과 : 100
		p.method(); //중복시 항상 실제 인스턴스 메서드 -> 결과 : Child Method

		System.out.println("c.x = " + c.x); //결과 : 200
		c.method(); //결과 : Child Method
	}
}

class Parent {
	int x = 100;

	void method() {
		System.out.println("Parent Method");
	}

}

class Child extends Parent{
	int x = 200;

	void method(){
		System.out.println("Child Method");
	}
}
```

하지만 위의 경우는 중복이 되었을 때 이야기고, 만일 중복이 없다면 그냥 있는 걸 사용한다.

```jsx
class BindingTest {
	public static void main(String[] args) {
		Parent p = new Child(); //참조변수 : Parent / 실제 인스턴스 : Child
		Child c = new Child(); //참조변수 : Child / 실제 인스턴스 : Child

		System.out.println("p.x = " + p.x); //결과 : 100
		p.method(); //결과 : Parent Method

		System.out.println("c.x = " + c.x); //결과 : 100
		c.method(); //결과 : Parent Method
	}
}

class Parent {
	int x = 100;

	void method() {
		System.out.println("Parent Method");
	}

}

class Child extends Parent{
}
```

자손 클래스에서 조상 클래스로부터 상속받은 인스턴스 변수를 구분하고자 `super`와 `this`를 사용할 수 있다.

> 위의 예시들에서는 다른 외부 클래스에서 참조변수를 통해 직접적으로 인스턴스변수에 접근할 수 있도록 하였으나, **실제로는 멤버변수들은 주로 private으로 접근을 제한하고, 외부에서는 메서드를 통해서만 멤버변수에 접근할 수 있도록 한다.** 인스턴스 변수에 직접 접근하면, 참조변수의 타입에 따라 사용되는 인스턴스 변수가 달라질 수 있기 때문에 주의해야 한다.
> 

## 5.5 매개변수의 다형성

메소드의 매개변수에도 다형적인 특징이 적용된다. 매개변수에 다형성을 적용한다는 것은 매개변수의 참조변수의 타입이 되는 클래스를 상속받은 자손 타입의 어느 것이나 그 자손 타입의 참조변수를 매개변수로 받아들일 수 있다는 뜻이다.

다음과 같은 예시를 들어보자.

```jsx
class Buyer {
	int money = 1000;
	int bonusPoint = 0;

	void buy(Tv t) {
		money = money - t.price;
		bonusPoint = bonusPoint + t.bonusPoint;
	}
}
```

위와 같은 코드가 있다면 다른 제품을 구매하려할 때마다 그 제품을 매개변수로 받는 새로운 메서드가 필요하다. 하지만 Product라는 조상클래스를 만들어 각 제품에 상속시킨다면? 매개변수에 Product p를 두어 하나의 메서드로 처리할 수 있다.

```jsx
void buy(Product p) {
	money = money - p.price;
	bonusPoint = bonusPoint + p.bonusPoint;
}

Buyer b = new Buyer();
Tv t = new Tv();
Computer c = new Computer();
b.buy(t);
b.buy(c);
```

또 다른 예시로, Object 타입의 변수를 매개변수로 선언한 경우에 하나의 메서드로 모든 타입의 인스턴스를 처리할 수 있다.

```jsx
public static String valueOf(Object obj) {
	return (obj == null) ? "null" : obj.toString();
}
```

## 5.6 여러 종류의 객체를 배열로 다루기

조상 타입의 참조변수 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있다.

# 6. 추상클래스(abstract class)

## 6.1 추상클래스란?

미완성 메서드인 추상메서드를 포함하고 있다는 의미로, 추상 클래스는 인스턴스를 생성할 수 없고 상속을 통해서 자손 클래스에 의해서만 완성될 수 있다.

새로운 클래스를 작성하는 데 있어 바탕이 되는 조상클래스로서 중요한 의미를 가진다. 

`abstract`키워드를 붙여서 만들 수 있으며, 클래스 선언부의 abstract를 보고 이 클래스에는 추상메서드가 있으니 상속을 통해서 구현해주어야 한다는 것을 쉽게 알 수 있다.

## 6.2 추상 메서드(abstract method)

선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상 메서드이다. 즉 설계만 해두고 실제 수행될 내용은 작성하지 않은 것이다.

추상메서드는 **메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문에 사용한다.** 주석을 덧붙여서 어떤 기능을 수행할 목적으로 작성되었는지만 알려주고, 실제 내용은 상속받는 클래스에서 구현할 수 있도록 비워둔다.

```java
/*주석으로 알려준다*/
abstract 리턴타입 메서드이름();
```

자손클래스는 `오버라이딩`을 통해 조상인 추상 클래스의 추상 메서드를 모두 구현해주어야 한다. (만일 하나라도 구현하지 않는다면 자손클래스도 추상클래스가 되어야 한다.)

## 6.3 추상 클래스의 작성

`추상화`와 `구체화`는 서로 반대되는 의미이다. 구체화가 상속을 통해 클래스를 구현하고 확장하는 작업(점점 기능이 추가됨)이라면, **추상화는 클래스 간의 공통점을 찾아내서 공통의 조상을 만드는 작업**이다.

abstract를 이용해 추상메서드로 정의해둔다면 자손 클래스를 작성할 때 추상메서드인 것을 인지하고 자신의 클래스에 알맞게 구현해줄 수 있다.

# 7. 인터페이스

## 7.1 인터페이스란?

인터페이스는 일종의 추상클래스인데, 추상화 정도가 높아서 추상클래스와 다르게 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.  오직 `추상메서드`와 `상수`만을 멤버로 가질 수 있으며, 그 외의 다른 어떠한 요소도 허용되지 않는다. 인터페이스도 그 자체만으로 사용되기 보단 다른 클래스를 작성하는 데 도움 줄 목적으로 작성된다.

## 7.2 인터페이스의 작성

키워드로 class 대신 `interface`를 사용한다. 접근제어자로 `public`, `default`를 사용할 수 있다.

다음과 같은 제약사항을 가진다.

- 모든 멤버변수는 public static final 이어야하며 생략 가능
- 모든 메서드는 public abstract 이어야 하며 생략 가능(단, 1.8 부터 static 메서드와 디폴트 메서드는 예외이다. 즉 원래는 인터페이스의 모든 메서드는 추상메서드여야 했는데, JDK 1.8부터 인터페이스에 static 메서드와 default 메서드의 추가를 허용하는 방향으로 변경되었다.)

## 7.3 인터페이스의 상속

인터페이스로부터만 상속받을 수 있고 다중 상속이 가능하다.

## 7.4 인터페이스의 구현

extends 대신 `implements`를 사용한다.

전부다 구현하지 않는다면 abstract를 붙여 추상 클래스로 선언해야한다.

상속과 구현을 동시에 사용할 수 있다. (extends, implements 둘 다 붙일 수 있음)

## 7.5 인터페이스를 이용한 다중상속

## 7.6 인터페이스를 이용한 다형성

**리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.**

## 7.7 인터페이스의 장점

- 개발 시간 단축
- 표준화 가능
- 서로 관계 없는 클래스들에게 관계를 맺어줄 수 있다.
- 독립적인 프로그래밍이 가능하다.

## 7.8 인터페이스의 이해

- 클래스를 사용하는 쪽과 클래스를 제공하는 쪽이 있다.
- 메서드를 사용하는 쪽에서는 사용하려는 메서드의 선언부만 알면 되지 내용은 몰라도 된다.

## 7.9 디폴트 메서드와 static 메서드

### 디폴트 메서드

인터페이스에 새로운 메서드를 추가하는 일이 너무 어려워서(인터페이스를 구현한 모든 기존의 클래스들에 메서드를 새로 구현해야 한다.) 디폴트 메서드를 만들어 냈다.

디폴트 메서드는 추상 메서드의 기본적인 구현을 제공하기 때문에 추상메서드가 아니라 디폴트 메서드가 새로 추가 되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.

# 8. 내부 클래스(inner class)

## 8.1 내부 클래스란?

내부 클래스는 클래스 내에 선언된 클래스 이다. 두 클래스가 긴밀한 관계에 있기 때문에 내부 클래스를 사용하곤 한다.

내부클래스의 장점은 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다는 점과 외부에 불필요한 코드를 감춰 코드의 복잡성을 줄일 수 있다는 장점(캡슐화)이 있다.

## 8.2 내부 클래스의 종류와 특징

- 인스턴스 클래스 : 외부 클래스의 인스턴스 멤버처럼 다뤄진다.
- 스태틱 클래스 : 외부 클래스의 static 멤버처럼 다뤄진다.
- 지역 클래스 : 선언된 영역 내부에서만 사용될 수 있다.
- 익명 클래스 : 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)

## 8.3 내부 클래스의 선언

```java
class Outer {
	class InstanceInner {}
	static class StaticInner {}
	void myMethod() {
		class LocalInner{}
	}
}
```

## 8.4 내부 클래스의 제어자와 접근성

교재 코드 참조

## 8.5 익명클래스

익명클래스는 이름이 없다. 클래스의 선언과 객체의 생성을 동시에 하기 때문에 한번만 사용될 수 있고 오직 하나의 객체만을 생성할 수 있는 일회용 클래스이다.

이름이 없어 생성자도 가질 수 없고 조상클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용해서 정의하기 때문에 하나의 클래스로 상속받는 동시에 인터페이스를 구현하거나 둘 이상의 인터페이스를 구현할 수 없다. 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.

## Chapter 11. 컬렉션 프레임웍(collections framework)
컬렉션 프레임웍 : 다수의 데이터, 즉 데이터 그룹을 저장하는 클래스들을 표준화한 설계
### 컬렉션 프레임웍의 핵심 인터페이스
|인터페이스|특징|구현 클래스|
|------|------|------|
|List|순서가 있는 데이터의 집합. 데이터의 중복을 허용|ArrayList, LinkedList, Stack, Vector 등|
|Set|순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않음|HashSet, TreeSet 등|
|Map|키와 값의 쌍으로 이루어진 데이터의 집합. 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용함|HashMap, TreeMap, Hashtable, Properties 등|

Vector나 HashTable과 같은 기존의 컬렉션 클래스들은 호환을 위해 남겨두었지만 가능하면 사용하지 않는 것이 좋다. 

### ArrayList
ArrayList는 List 인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고 중복을 허용한다는 특징을 갖는다.  
Object 배열을 이용해서 데이터를 순차적으로 저장하며, 배열에 더이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장된다.  

ArrayList나 Vector와 같이 배열을 이용한 자료구조는 데이터를 읽어오고 저장하는 데는 효율이 좋지만, 
`용량을 변경해야 할 때는 새로운 배열을 생성한 후 기존의 배열로부터 새로 생성된 배열로 데이터를 복사`해야하기 때문에 상당히 효율이 떨어진다는 단점을 가진다.

### LinkedList
배열은 가장 기본적인 형태의 자료구조로 구조가 간단하며 사용하기 쉽고 데이터를 읽어 오는데 걸리는 시간이 가장 빠르다는 장점을 가진다. 하지만 다음의 단점이 존재한다.
1. 크기를 변경할 수 없다. 따라서 새로운 배열을 생성해서 데이터를 복사해야 한다. 이를 막기 위해서는 충분히 큰 크기의 배열을 생성해야 하는데 이는 메모리를 낭비시킨다.
2. 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다. 배열의 중간에 데이터를 추가하려면 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야 한다.

LinkedList는 이런 배열의 단점을 보완한다. 링크드 리스트는 불연속적으로 존재하는 데이터를 서로 연결한 형태로 구성되어 있다.
```
class Node {
  Node next; //다음 요소의 주소를 저장
  Object obj; //데이터를 저장
}
```

LinkedList에서는 삭제하고자 하는 요소의 이전요소가 삭제하고자 하는 요소의 다음 요소를 참조하도록 `하나의 참조만 변경하면 삭제가 이루어지기` 때문에 처리 속도가 매우 빠르다.  
새로운 데이터에 대한 추가도 마찬가지로 참조 관계만 변경해주면 되므로 처리속도가 매우 빠르다.

LinkedList는 `이동방향이 단방향`이기 때문에 다음 요소에 대한 접근은 쉽지만 이전요소에 대한 접근은 어렵다. 이를 보완한 것이 이중 연결리스트(doubly linked list)이다.  
```
class Node {
  Node next; //다음 요소의 주소를 저장
  Node previouse; //이전 요소의 주소를 저장
  Object obj; //데이터를 저장
}
```

더블 링크드 리스트보다 접근성을 보다 향상시킨 것이 '이중 원형 연결리스트(doubly circular linked list)'인데, 단순히 더블 링크드 리스트의 첫번째 요소와 마지막 요소를 서로 연결한 것이다.  
이렇게 하면, 마지막 요소의 다음 요소가 첫번째 요소가 되고, 첫번째 요소의 이전 요소가 마지막 요소가 된다. 

**결론**
- 순차적으로 추가/삭제하는 경우 ArrayList가 LinkedList보다 빠르다.
- 중간 데이터를 추가/삭제하는 경우에는 LinkedList가 ArrayList보다 빠르다.
- ArrayList는 각 요소들이 연속적인 메모리상에 존재해 접근 시간이 빠르다. 하지만 LinkedList는 각 요소들이 서로 연결되어 있어 처음부터 n번째 데이터까지 차례대로 따라가야 하므로 접근 시간이 비교적 느리다.

### Stack과 Queue
- 스택 : 마지막에 저장한 데이터를 가장 먼저 꺼내게 되는 LIFO(Last In First Out) 구조 - ArrayList 구현이 적합
- 큐 : 처음에 저장한 데이터를 가장 먼저 꺼내게 되는 FIFO(First In First Out) 구조 - LinkedList 구현이 적합
- 우선순위 큐 : Queue 인터페이스의 구현체 중 하나로, 저장한 순서와 관계없이 우선순위가 높은 것부터 꺼내며, null은 저장할 수 없다. 저장공간으로 배열을 사용하며, 각 요소를 '힙(heap)' 형태로 저장한다.
- Deque(Double-Ended Queue) : Deque는 양쪽 끝에서 추가/삭제가 가능하다. 구현체로는 ArrayDeque와 LinkedList 등이 있다. 

### Iterator, ListIterator, Enumeration
Iterator, ListIterator, Enumeration는 모두 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스이다.

```
ListIterator : iterator에 양방향 조회 기능 추가. List 인터페이스를 구현한 경우만 사용 가능
Enueration : iterator의 구버전. 되도록이면 iterator를 사용할 것
```

iterator 인터페이스 메서드
|메서드|설명|
|------|------|
|boolean hasNext()|읽어올 요소가 있으면 true, 없으면 false|
|Object next()|다음 요소를 읽어옴|
|void remove()|next()로 읽어온 요소를 삭제(선택적 기능)|

※ Map 인터페이스를 구현한 컬렉션 클래스는 키와 값을 쌍으로 저장하므로 iterator()를 직접 호출할 수 없고, keySet()이나 entrySet()을 통해 Set의 형태로 얻어온 후 호출 가능하다.  


## Chapter 07. 객체지향 프로그래밍 II
### 7.4. 제어자(modifier)  
**제어자** : 클래스, 변수, 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여, 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.  
- static 
   - '클래스의', '공통적인' 의미를 갖는다. static이 붙은 멤버변수, 메서드, 초기화 블럭은 `인스턴스가 아닌 클래스에 관계된 것으로 인스턴스를 생성하지 않고도 사용 가능`하다. 
   - 인스턴스 멤버를 사용하지 않는 메서드에 대해 static 메서드 선언을 고려해볼 수 있다.
- final
   - '마지막의', '변경될 수 없는'의 의미를 갖는다.
   - `변수`에 적용되면 `상수`가 되며, `메서드`에 사용되면 `오버라이딩을 할 수 없게` 되고, `클래스`에 사용되면 `자손클래스를 정의하지 못하게` 된다.
   - 인스턴스 변수의 경우 생성자에서 초기화 되도록 할 수 있으므로 매개변수를 갖는 생성자를 이용하여 final이 붙은 멤버변수가 각 인스턴스마다 다른 값을 갖도록 하는 것이 가능하다.
   >스프링부트 프로젝트에서 주로 멤버변수를 private final로 선언하고 @RequiredArgsConstructor 애노테이션을 붙여서 의존성이 생성자를 통해 주입될 수 있도록 한다. 
   >이 경우 final로 선언하여 불변성을 보장할 수 있게 되는 것이다!
- abstract
   - '미완성의'의 의미를 가진다. `메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드`를 선언하는데 사용된다.
   - 추상클래스는 자체로는 인스턴스를 생성할 수 없지만, 다른 클래스가 이 클래스를 상속받아서 일부의 원하는 메서드만 오버라이딩하여 사용 할 수 있다.

**접근 제어자**
- private : 같은 클래스 내에서만 접근 가능
- default : 같은 패키지 내에서만 접근 가능
- protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근 가능
- public : 접근 제한이 없음  
  
접근 제어자를 이용하여 외부로부터 데이터를 보호하고, 외부에는 불필요한(내부적으로만 사용) 부분을 감추는 `캡슐화`가 가능하다.  
생성자에 접근 제어자를 private으로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스의 생성을 제한할 수 있다.
> 싱글톤 객체의 경우가 이 케이스! 생성자의 접근 제어자를 private으로 지정해서 인스턴스의 생성을 막는 대신, getInstance() 메서드를 public static으로 선언하여 제공함으로써 이 클래스의 인스턴스를 하나만 반환 받아 사용할 수 있게 한다.  

제어자의 조합
```
1. 메서드에 static과 abstract를 함께 사용할 수 없다.
2. 클래스에 abstract와 final을 함께 사용할 수 없다.
3. abstract 메서드의 접근 제어자가 private 일 수 없다.
4. 메서드에 private과 final을 같이 사용할 필요는 없다.
```
#
### 7.5. 다형성(polymorphism)
**다형성** : 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다.  
        구체적으로는, `조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다는 것!`  

Tv 클래스와 Tv클래스를 상속받는 CaptionTv 클래스가 있다고 하자. 이 경우 다음 두가지의 인스턴스 생성이 가능하다.  
```
Tv t = new Tv();  
CaptionTv c = new CaptionTv();  
```
그러나 조상 타입의 참조변수로 자손 인스턴스를 참조할 경우, CaptionTV 인스턴스의 모든 멤버를 사용할 수 없고 상속받은 Tv 클래스의 멤버들만 사용할 수 있다.  
또한 CaptionTv ct = new Tv()와 같이 자손 타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 불가능하다. 실제 인스턴스인 Tv보다 참조변수 ct가 사용할 수 있는 멤버의 개수가 더 많기 때문이다.  
메서드의 경우 참조 변수의 타입과 상관없이 항상 실제 인스턴스의 메서드가 호출된다. 하지만 멤버변수의 경우 중복으로 정의되었을 때 참조변수에 따라 다르게 호출된다.  
  
**형변환**  
```
자손 타입 -> 조상 타입(UP-CASTING) : 형변환 생략 가능
자손 타입 <- 조상 타입(DOWN-CASTING) : 형변환 생략 불가
```

형변환은 참조변수의 타입을 변경하는 것이지, 인스턴스를 변환하는 것이 아니기 때문에 인스턴스에 영향을 미치지 않는다. 단지 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위를 조절할 뿐!  

**instanceOf 연산자**
- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceOf 연산자를 주로 사용한다. 주로 조건문에 사용되며 *참조변수 instanceOf 타입* 형식으로 쓰인다. 연산의 결과로는 true, false를 반환한다.  
- 자손 클래스의 인스턴스인 경우, 조상 클래스 타입에 대해서도 true를 반환한다. 이는 곧, 검사한 타입으로 형변환을 해도 괜찮다는 의미이다.  

**메개변수의 다형성**
```
class Product {}
class Tv extends Product {}
class Computer extends Product {}
class Audio extends Product {}
```
참조 변수의 다형적인 특징은 메서드의 매개변수에도 적용된다. 물건을 구매하는 메서드가 존재한다고 할 때, 우리가 buy(Tv t), buy(Computer c), buy(Audio a)와 같이 메서드를 오버로딩한다면, 물건이 늘어날 때마다 메서드가 추가되어야 한다.  
그러나 `void buy(Product p)`와 같이 작성하면 매개변수로 Product 클래스의 자손타입의 참조변수면 모두 가능해진다!!  
#
### 7.6. 추상 클래스(abstract class)
**추상 클래스** : 추상클래스는 미완성 메서드(추상 메서드)를 포함하고 있다는 의미로 그 자체로는 인스턴스를 생성할 수 없고, 상속을 통해 자손클래스에 의해서만 완성될 수 있다.  

**추상화**란 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업으로 상속을 통해 클래스를 확장하는 구체화의 반대되는 의미를 갖는다. 
**추상 메서드**는 구현부가 없이 선언부로만 이루어져있는데, 우리는 `추상 메서드로 선언함으로써 자손 클래스에서 추상 메서드를 반드시 구현하도록 강제`할 수 있다.  
만약 추상메서드로 정의하지 않고 빈 몸통만 가지도록 정의한다면, 자손 클래스에서는 이 메서드들이 온전히 구현된 것으로 인식하고 오버라이딩을 통해 자신의 클래스에 맞게 구현하지 않을 수도 있다. 이는 구현되지 않은 메서드에 대한 참조를 가능하게 할 수도 있어 위험하다!  
#
### 7.7. 인터페이스(interface)
**인터페이스** : 인터페이스는 일종의 추상 클래스이다. 추상 클래스처럼 추상메서드를 갖지만, 추상 클래스보다 추상화 정도가 높아서 추상클래스와 달리 일반 메서드나 멤버변수를 구성원으로 가질 수 없다.  
                `오직 추상메서드와 상수만`을 멤버로 가질 수 있다.  
 
 ```
 인터페이스의 모든 멤버변수는 public static final 이어야 하며, 생략 가능하다.
 인터페이스의 모든 메서드는 public abstract 이어야 하며, 생략 가능하다.
 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와 달리 다중 상속이 가능하다.
 ```
 
 **인터페이스를 이용한 다형성**
 인터페이스 역시 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스 타입으로의 형변환도 가능하다.  
 리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.  
 
 **인터페이스의 장점**
 - 메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 선언부만 알면 되기 때문에 개발 시간을 단축할 수 있다.
 - 기본 틀을 인터페이스로 작성한 다음, 인터페이스를 구현하여 프로그램을 작성하게 함으로써 일관되고 정형화된 개발이 가능하다.
 - 서로 관계없는 클래스들에게 관계를 맺어줄 수 있다.
 - 인터페이스를 이용하면 `클래스의 선언과 구현을 분리시켜 실제 구현에 독립적인 프로그램을 작성하는 것이 가능`하다.
 
 >DIP 의존관계 역전 원칙
 >프로그래머는 '추상화에 의존해야지, 구체화에 의존하면 안된다.'  
 >즉, 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 한다. 그래야 유연하게 구현체를 변경할 수 있다!
 
 ```
 class A {
  public void methodA(B b) {
    b.methodB();
  }
 }
 ```
 
 다음의 클래스를 다음과 같이 수정할 수 있다.
 
 ```
 class A {
  public void methodA(I i){
    i.methodB();
  }
 }
 ```
 
클래스 A를 작성하는데 클래스 B가 사용되지 않았다는 점이 중요하다.  A-B 관계가 아닌, A-I-B 관계가 된 것이다.  
따라서 클래스 A는 클래스 B의 변경에 영향을 받지 않을 수 있게 되었다. A는 I의 영향만 받으며, 이 안에 구현체가 B인지, C인지는 전혀 몰라도 된다.  
#
### 7.8. 내부 클래스(inner class)
**내부 클래스** : 클래스 내에 선언된 클래스이다. 내부 클래스를 사용하면 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있고, 외부에 불필요한 클래스를 감추는 캡슐화를 통해 코드의 복잡성을 줄일 수 있다.  
- 인스턴스 클래스 : 외부 클래스의 멤버변수 선언위치에 선언하며, 인스턴스 멤버처럼 다뤄짐. 외부 클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적.
- 스태틱 클래스 : 외부 클래스의 멤버변수 선언위치에 선언하며, static 멤버처럼 다뤄짐. 외부 클래스의 static 멤버, 메서드에서 사용될 목적.
- 지역 클래스 : 외부 클래스의 메서드나 초기화블럭 안에 선언, 선언된 영역 내부에서만 사용 가능.
- 익명 클래스 : 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용).  

---
> 코틀린의 스마트 캐스트  
> 코틀린에서는 is를 사용해 변수 타입을 검사한다. 자바의 instanceOf 와 비슷한 것인데, 자바에서는 어떤 변수의 타입을 instanceOf로 확인한 다음에 그 타입에 속한 멤버에 접근하기 위해서는
> 명시적으로 변수 타입을 캐스팅 해야 한다. (instanceOf의 값이 true라는 것은, 그 타입으로 캐스팅할 수 있다는 것.)   
> 그러나 **코틀린에서는 어떤 변수가 원하는 타입인지 is로 검사하고 나면, 굳이 변수를 원하는 타입으로 캐스팅하지 않아도 처음부터 그 변수가 원하는 타입으로 선언된 것처럼 사용할 수 있다.**  
> 실제로는 컴파일러가 캐스팅을 수행해주는데, 이를 **스마트 캐스트**라고 한다.
